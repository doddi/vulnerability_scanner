package org.sonatype.vul_highlighter.service.impl;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

import org.sonatype.goodies.packageurl.PackageUrl;
import org.sonatype.vul_highlighter.module.LibraryToScan;
import org.sonatype.vul_highlighter.module.VulnerableComponent;
import org.sonatype.vul_highlighter.service.ScannerService;
import org.sonatype.vul_highlighter.service.VulnerabilityService;

import org.jetbrains.annotations.NotNull;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import static org.sonatype.vul_highlighter.listener.maven.JarParser.findClasses;

public class VulnerabilityServiceImpl
    implements VulnerabilityService
{
  public static final Logger LOGGER = LoggerFactory.getLogger(VulnerabilityServiceImpl.class);

  private final Map<String, VulnerableComponent> components = new HashMap<>();

  @Override
  public void checkLibraries(final Set<LibraryToScan> libraries) {
    final ScannerService scannerService = ScannerService.getInstance();

    final List<PackageUrl> componentsToScan = collectPackageUrls(libraries);
    final List<VulnerableComponent> vulnerableComponents = scannerService.scan(componentsToScan);
    populateComponentClassNames(libraries, vulnerableComponents);
    populateVulnerableComponents(vulnerableComponents);
  }

  @NotNull
  private List<PackageUrl> collectPackageUrls(final Set<LibraryToScan> libraries) {
    return libraries.stream()
        .map(LibraryToScan::getPackageUrl)
        .collect(Collectors.toList());
  }

  private void populateComponentClassNames(final Set<LibraryToScan> librariesScanned,
                                           final List<VulnerableComponent> vulnerableLibraries)
  {
    for (VulnerableComponent component : vulnerableLibraries) {
      librariesScanned.stream()
          .filter(library -> library.getPackageUrl().equals(component.getPackageUrl()))
          .findFirst()
          .ifPresent(scannedLibrary -> populateClasses(component, scannedLibrary));
    }
  }

  private void populateClasses(final VulnerableComponent component, final LibraryToScan scannedLibrary) {
    LOGGER.info("Collecting class names contained in {}", scannedLibrary.getFile().getName());
    final String presentableUrl = scannedLibrary.getFile().getPresentableUrl();
    final List<String> classes = findClasses(presentableUrl);
    component.setClasses(classes);
  }

  private void populateVulnerableComponents(final List<VulnerableComponent> vulnerableComponents) {
    components.clear();
    vulnerableComponents.forEach(component -> components.put(component.getPackageUrl().toString(), component));
  }

  @Override
  public Optional<VulnerableComponent> isVulnerable(final String name) {
    return components.values().stream()
        .filter(component -> component.getClasses().contains(name))
        .findFirst();
  }

  @Override
  public Map<String, VulnerableComponent> getVulnerableComponents() {
    return this.components;
  }
}
