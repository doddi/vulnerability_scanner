package org.sonatype.vul_highlighter.listener.maven;


import java.util.Optional;

import javax.swing.*;

import org.sonatype.vul_highlighter.marker.ViolationIcons;
import org.sonatype.vul_highlighter.marker.ViolationMarker;
import org.sonatype.vul_highlighter.module.VulnerableComponent;
import org.sonatype.vul_highlighter.service.VulnerabilityService;

import com.intellij.codeInsight.daemon.LineMarkerInfo;
import com.intellij.psi.PsiElement;
import com.intellij.psi.PsiJavaCodeReferenceElement;
import com.intellij.psi.impl.source.PsiImportStatementImpl;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public class MavenViolationMarker
    extends ViolationMarker
{
  public static final Logger LOGGER = LoggerFactory.getLogger(MavenViolationMarker.class);

  @Override
  public String getName() {
    return "Policy Violation";
  }

  @Nullable
  @Override
  public LineMarkerInfo getLineMarkerInfo(@NotNull final PsiElement element) {
    if (element instanceof PsiImportStatementImpl) {
      final PsiJavaCodeReferenceElement importReference = ((PsiImportStatementImpl) element).getImportReference();

      if(importReference != null) {
        final Optional<VulnerableComponent> vulnerable = VulnerabilityService.getInstance()
            .isVulnerable(importReference.getQualifiedName());

        if (vulnerable.isPresent()) {
          LOGGER.info("Vulnerabilities found for {}", importReference.getQualifiedName());
          return markVulnerable(element, vulnerable);
        }
      }
    }
    return null;
  }

  @Nullable
  @Override
  public Icon getIcon() {
    return ViolationIcons.ALERT;
  }
}
