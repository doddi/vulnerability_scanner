package com.doddi.vulnerability_scanner_idea_plugin.service.vulnerability;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.sonatype.goodies.packageurl.PackageUrl;

import com.doddi.vulnerability_scanner_idea_plugin.entity.VulnerableComponent;
import com.doddi.vulnerability_scanner_idea_plugin.service.VulnerabilityCacheService;
import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import static java.util.concurrent.TimeUnit.MILLISECONDS;

public class VulnerabilityCacheServiceImpl
    implements VulnerabilityCacheService
{
  private static final int DEFAULT_MAX_CACHE_SIZE = 10000;

  private static final int DEFAULT_CACHE_EXPIRATION_IN_MILLIS = 60 * 60 * 1000; // 60 minutes

  private int maxCacheSize = DEFAULT_MAX_CACHE_SIZE;

  private int cacheExpirationInMillis = DEFAULT_CACHE_EXPIRATION_IN_MILLIS;

  private Cache<PackageUrl, CachedScanResult> cache;

  public VulnerabilityCacheServiceImpl() {
    rebuildCache();
  }

  public void setMaxCacheSize(final int maxCacheSize) {
    this.maxCacheSize = maxCacheSize;
    rebuildCache();
  }

  public void setCacheExpiration(final int millis) {
    this.cacheExpirationInMillis = millis;
    rebuildCache();
  }

  @Override
  public void cache(@NotNull final VulnerableComponent component) {
    cache.put(component.getPackageUrl(), new CachedScanResult(component));
  }

  @Override
  public void cache(@NotNull final Collection<VulnerableComponent> components) {
    for (VulnerableComponent component : components) {
      cache(component);
    }
  }

  @Override
  public void cacheNonVulnerableComponents(final Collection<PackageUrl> purls) {
    for (PackageUrl purl : purls) {
      cacheNonVulnerableComponent(purl);
    }
  }

  @Override
  public void cacheNonVulnerableComponent(final PackageUrl purl) {
    cache.put(purl, new CachedScanResult(null));
  }

  @Override
  public CachedScanResult get(@NotNull final PackageUrl url) {
    return cache.getIfPresent(url);
  }

  @Override
  public CacheResult get(@NotNull final Collection<PackageUrl> purls) {
    Set<CachedScanResult> cached = new HashSet<>();
    Set<PackageUrl> notCached = new HashSet<>();

    for (PackageUrl purl : purls) {
      CachedScanResult cachedScanResult = cache.getIfPresent(purl);
      
      if (cachedScanResult == null) {
        notCached.add(purl);
      }
      else {
        cached.add(cachedScanResult);
      }
    }

    return new CacheResult(cached, notCached);
  }

  private void rebuildCache() {
    cache = CacheBuilder.newBuilder()
        .maximumSize(maxCacheSize)
        .expireAfterWrite(cacheExpirationInMillis, MILLISECONDS)
        .build();
  }

  public static class CacheResult
  {
    private final Set<CachedScanResult> cachedComponents = new HashSet<>();

    private final List<PackageUrl> notFoundInCache = new ArrayList<>();

    public CacheResult(@NotNull final Collection<CachedScanResult> cachedComponents,
                       @NotNull final Collection<PackageUrl> notFoundInCache)
    {
      this.cachedComponents.addAll(cachedComponents);
      this.notFoundInCache.addAll(notFoundInCache);
    }

    public Set<CachedScanResult> getCachedComponents() {
      return cachedComponents;
    }

    public List<PackageUrl> getNotFoundInCache() {
      return notFoundInCache;
    }
  }
  
  public static class CachedScanResult {
    private final VulnerableComponent vulnerableComponent;

    public CachedScanResult(final VulnerableComponent vulnerableComponent) {this.vulnerableComponent = vulnerableComponent;}
    
    @Nullable
    public VulnerableComponent getVulnerableComponent() {
      return vulnerableComponent;
    }
  }
}
