package com.doddi.vulnerability_scanner_idea_plugin.service.vulnerability;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;

import org.sonatype.goodies.packageurl.PackageUrl;

import com.doddi.vulnerability_scanner_idea_plugin.entity.LibraryToScan;
import com.doddi.vulnerability_scanner_idea_plugin.entity.VulnerableComponent;
import com.doddi.vulnerability_scanner_idea_plugin.service.ScannerManagerService;
import com.doddi.vulnerability_scanner_idea_plugin.service.VulnerabilityCacheService;
import com.doddi.vulnerability_scanner_idea_plugin.service.VulnerabilityService;
import com.doddi.vulnerability_scanner_idea_plugin.service.vulnerability.VulnerabilityCacheServiceImpl.CacheResult;
import com.doddi.vulnerability_scanner_idea_plugin.service.vulnerability.VulnerabilityCacheServiceImpl.CachedScanResult;
import com.doddi.vulnerability_scanner_idea_plugin.system.Populator;
import com.intellij.codeInsight.daemon.DaemonCodeAnalyzer;
import com.intellij.openapi.diagnostic.Logger;
import com.intellij.openapi.project.Project;
import org.jetbrains.annotations.NotNull;

import static java.util.Collections.emptyMap;
import static java.util.stream.Collectors.toList;

public class VulnerabilityServiceImpl
    implements VulnerabilityService
{
  public static final Logger LOGGER = Logger.getInstance(VulnerabilityServiceImpl.class);

  private Populator populator;

  @Override
  public void setPopulator(final Populator populator) {
    this.populator = populator;
  }

  @Override
  public void checkLibraries(final Project project, final Set<LibraryToScan> libraries) {
    final List<PackageUrl> componentsToScan = collectPackageUrls(libraries);

    List<VulnerableComponent> vulnerableComponents = new ArrayList<>();

    CacheResult cacheResult = fetchCachedComponents(project, componentsToScan, vulnerableComponents);

    fetchAndCacheNewComponents(project, vulnerableComponents, cacheResult);

    // Only repopulate the class list if there were new non-cached libraries found.
    if (!cacheResult.getNotFoundInCache().isEmpty()) {
      populate(libraries, vulnerableComponents, populator);
      updateAnnotations(project);
    }
  }

  public void updateAnnotations(final Project project) {
    LOGGER.info("Refreshing annotations");
    final DaemonCodeAnalyzer instance = DaemonCodeAnalyzer.getInstance(project);
    instance.restart();
  }

  @NotNull
  private CacheResult fetchCachedComponents(final Project project,
                                            final List<PackageUrl> componentsToScan,
                                            final List<VulnerableComponent> vulnerableComponents)
  {
    final VulnerabilityCacheService cacheService = VulnerabilityCacheService.getInstance(project);
    CacheResult cacheResult = cacheService.get(componentsToScan);

    cacheResult.getCachedComponents().stream()
        .filter(c -> c.getVulnerableComponent() != null)
        .map(CachedScanResult::getVulnerableComponent)
        .forEach(vulnerableComponents::add);
    
    return cacheResult;
  }

  private void fetchAndCacheNewComponents(final Project project,
                                          final List<VulnerableComponent> vulnerableComponents,
                                          final CacheResult cacheResult)
  {
    final ScannerManagerService scannerManagerService = ScannerManagerService.getInstance();
    final VulnerabilityCacheService cacheService = VulnerabilityCacheService.getInstance(project);

    final List<PackageUrl> notFoundInCache = cacheResult.getNotFoundInCache();

    if (!notFoundInCache.isEmpty()) {
      //Scan and cache components that have vulnerabilities
      final List<VulnerableComponent> newVulnerableComponents = scannerManagerService.scan(project, notFoundInCache);
      cacheService.cache(newVulnerableComponents);
      vulnerableComponents.addAll(newVulnerableComponents);

      //Cache all components that weren't returned in the scan so that we don't scan them again until the cache expires
      for (PackageUrl purl : notFoundInCache) {
        if (cacheService.get(purl) == null) {
          cacheService.cacheNonVulnerableComponent(purl);
        }
      }
    }
  }

  private void populate(final Set<LibraryToScan> libraries,
                        final List<VulnerableComponent> vulnerableComponents,
                        final Populator populator)
  {
    if (populator == null) {
      LOGGER.error("Attempting to scan without a populator");
      return;
    }
    populator.populate(libraries, vulnerableComponents);
  }

  @NotNull
  private List<PackageUrl> collectPackageUrls(final Set<LibraryToScan> libraries) {
    return libraries.stream()
        .map(LibraryToScan::getPackageUrl)
        .collect(toList());
  }

  @Override
  public Optional<VulnerableComponent> isVulnerable(final String name) {
    return populator.isVulnerable(name);
  }

  @Override
  public Map<String, VulnerableComponent> getVulnerableComponents() {
    if (this.populator == null) {
      LOGGER.warn("Populator is null, no components will be scanned");

      return emptyMap();
    }

    return this.populator.getVulnerableComponents();
  }
}
