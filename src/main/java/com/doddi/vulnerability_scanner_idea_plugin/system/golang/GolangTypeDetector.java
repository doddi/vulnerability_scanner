package com.doddi.vulnerability_scanner_idea_plugin.system.golang;

import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.HashSet;
import java.util.Locale;
import java.util.Set;

import org.sonatype.goodies.packageurl.PackageUrl;
import org.sonatype.goodies.packageurl.PackageUrlBuilder;

import com.doddi.vulnerability_scanner_idea_plugin.entity.LibraryToScan;
import com.doddi.vulnerability_scanner_idea_plugin.system.FileBasedDetector;
import com.doddi.vulnerability_scanner_idea_plugin.system.Populator;
import com.doddi.vulnerability_scanner_idea_plugin.system.ProjectTypeDetector;
import com.intellij.openapi.diagnostic.Logger;
import com.intellij.openapi.project.Project;
import com.opencsv.CSVParserBuilder;
import com.opencsv.CSVReader;
import com.opencsv.CSVReaderBuilder;
import com.opencsv.ICSVParser;
import com.opencsv.exceptions.CsvValidationException;

public class GolangTypeDetector extends FileBasedDetector
{
    public static final Logger LOGGER = Logger.getInstance(ProjectTypeDetector.class);

    public static final String GOLANG_TYPE = "Golang";

    private final Populator populator;

    public GolangTypeDetector() {
        super("go.sum");
        populator = new GolangPopulator();
    }

    @Override
    public String getLanguageType() {
        return GOLANG_TYPE;
    }

    @Override
    public Set<LibraryToScan> getLibraryToScans(final Project project) {
        return getDependencies(project.getPresentableUrl() + "/" + filename);
    }

    private Set<LibraryToScan> getDependencies(String fileName) {
        Set<LibraryToScan> libraryToScans = new HashSet<>();

        try(CSVReader reader = createCvsReader(fileName)) {
            String[] record;
            while ((record = reader.readNext()) != null) {
                int index = record[0].lastIndexOf('/');
                if (index != -1) {
                    String namespace = record[0].substring(0, index);
                    String name = record[0].substring(index + 1);
                    String version = record[1];

                    if (!version.endsWith("/go.mod")) {
                        PackageUrl packageUrl = new PackageUrlBuilder()
                                .type("golang")
                                .namespace(namespace)
                                .name(name)
                                .version(version.replace("/go.mod", ""))
                                .build();
                        libraryToScans.add(new LibraryToScan(packageUrl, null));
                    }
                }
            }
        } catch (IOException | CsvValidationException e) {
            LOGGER.error("Unable to get dependencies", e.getCause());
        }
        return libraryToScans;
    }

    private CSVReader createCvsReader(final String filename) throws FileNotFoundException {
        return new CSVReaderBuilder(new FileReader(filename))
                .withCSVParser(new CSVParserBuilder()
                        .withSeparator(' ')
                        .withQuoteChar(ICSVParser.DEFAULT_QUOTE_CHARACTER)
                        .withEscapeChar(ICSVParser.DEFAULT_ESCAPE_CHARACTER)
                        .withStrictQuotes(ICSVParser.DEFAULT_STRICT_QUOTES)
                        .withIgnoreLeadingWhiteSpace(ICSVParser.DEFAULT_IGNORE_LEADING_WHITESPACE)
                        .withIgnoreQuotations(ICSVParser.DEFAULT_IGNORE_QUOTATIONS)
                        .withFieldAsNull(ICSVParser.DEFAULT_NULL_FIELD_INDICATOR)
                        .withErrorLocale(Locale.getDefault())
                        .build())
                .build();
    }

    @Override
    public Populator getPopulator() {
        return populator;
    }
}
