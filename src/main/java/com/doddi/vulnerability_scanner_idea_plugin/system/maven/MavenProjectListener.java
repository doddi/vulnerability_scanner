package com.doddi.vulnerability_scanner_idea_plugin.system.maven;

import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;

import org.sonatype.goodies.packageurl.PackageUrl;

import com.doddi.vulnerability_scanner_idea_plugin.entity.LibraryToScan;
import com.doddi.vulnerability_scanner_idea_plugin.service.VulnerabilityService;
import com.intellij.jarRepository.RepositoryLibrarySynchronizer;
import com.intellij.openapi.diagnostic.Logger;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.roots.OrderRootType;
import com.intellij.openapi.roots.libraries.Library;
import com.intellij.openapi.vfs.VirtualFile;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.idea.maven.project.MavenProjectsManager.Listener;

public class MavenProjectListener implements Listener
{
  private final static Logger LOGGER = Logger.getInstance(MavenProjectListener.class);

  private final Project project;

  public MavenProjectListener(final Project project) {
    this.project = project;
    final MavenPopulator populator = MavenPopulator.getInstance(project);

    if (populator == null) {
      LOGGER.error(String.format("Unable to create populator for project %s", project));
      return;
    }
    VulnerabilityService.getInstance(project).setPopulator(populator);
  }

  @Override
  public void activated() {
    LOGGER.info(String.format("Maven project %s activated", project.getName()));
    checkForUpdate();
  }

  @Override
  public void projectImportCompleted() {
    LOGGER.info(String.format("Maven project %s imported", project.getName()));
    checkForUpdate();
  }

  public void checkForUpdate() {
    final VulnerabilityService vulnerabilityService = VulnerabilityService.getInstance(project);
    final Set<LibraryToScan> libraries = getLibraries();

    if (!libraries.isEmpty()) {
      vulnerabilityService.checkLibraries(project, libraries);
    }
    else {
      LOGGER.info("No libraries found - doing nothing");
    }
  }

  Set<LibraryToScan> getLibraries() {
    return RepositoryLibrarySynchronizer.collectLibraries(project, library -> true)
        .stream()
        .filter(library -> library.getName() != null)
        .map(this::collectLibrariesToScan)
        .filter(Objects::nonNull)
        .collect(Collectors.toSet());
  }

  @Nullable
  private LibraryToScan collectLibrariesToScan(final Library library) {
    if (library.getName() == null) return null;
    final PackageUrl packageUrl = getPackageUrl(library.getName());
    if (packageUrl == null) return null;

    return new LibraryToScan(packageUrl, getClassFile(library));
  }

  private VirtualFile getClassFile(final Library library) {
    final VirtualFile[] files = library.getFiles(OrderRootType.CLASSES);
    if (files.length > 0 && files[0].exists()) {
      return files[0];
    }
    return null;
  }

  private PackageUrl getPackageUrl(final String library) {
    final String[] split = library.toLowerCase().split(":");
    if (split.length < 4) {
      return null;
    }
    return PackageUrl.builder()
        .type("maven")
        .namespace(split[1].trim())
        .name(split[2].trim())
        .version(split[3].trim())
        .qualifier("type", "jar")
        .build();
  }
}
