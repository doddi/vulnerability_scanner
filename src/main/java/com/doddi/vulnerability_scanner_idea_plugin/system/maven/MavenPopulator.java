package com.doddi.vulnerability_scanner_idea_plugin.system.maven;

import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;

import org.sonatype.goodies.packageurl.PackageUrl;

import com.doddi.vulnerability_scanner_idea_plugin.entity.LibraryToScan;
import com.doddi.vulnerability_scanner_idea_plugin.entity.VulnerableComponent;
import com.doddi.vulnerability_scanner_idea_plugin.system.Populator;
import com.intellij.openapi.components.ServiceManager;
import com.intellij.openapi.diagnostic.Logger;
import com.intellij.openapi.project.Project;

import static com.doddi.vulnerability_scanner_idea_plugin.system.maven.JarParser.findClasses;

public class MavenPopulator
    extends Populator
{
  public static final Logger LOGGER = Logger.getInstance(MavenPopulator.class);

  static public MavenPopulator getInstance(final Project project) {
    return ServiceManager.getService(project, MavenPopulator.class);
  }

  @Override
  public void populate(final Set<LibraryToScan> libraries, final List<VulnerableComponent> vulnerableComponents) {
    populateComponentClassNames(libraries, vulnerableComponents);
    populateVulnerableComponents(vulnerableComponents);
  }

  @Override
  public Map<String, VulnerableComponent> getVulnerableComponents() {
    return components;
  }

  @Override
  public Optional<VulnerableComponent> isVulnerable(final String name) {
    return components.values().stream()
        .filter(component -> component.getClasses().contains(name))
        .findFirst();
  }

  @Override
  public Optional<VulnerableComponent> isPackageVulnerable(final PackageUrl packageUrl) {
    return components.values().stream()
        .filter(pack -> pack.getPackageUrl().equals(packageUrl))
        .findFirst();
  }

  private void populateComponentClassNames(final Set<LibraryToScan> librariesScanned,
                                           final List<VulnerableComponent> vulnerableLibraries)
  {
    for (VulnerableComponent component : vulnerableLibraries) {
      librariesScanned.stream()
          .filter(library -> library.getPackageUrl().equals(component.getPackageUrl()))
          .findFirst()
          .ifPresent(scannedLibrary -> populateClasses(component, scannedLibrary));
    }
  }

  private void populateClasses(final VulnerableComponent component, final LibraryToScan scannedLibrary) {
    if (scannedLibrary.getFile() != null) {
      LOGGER.info(String.format("Collecting class names contained in %s", scannedLibrary.getFile().getName()));
      final String presentableUrl = scannedLibrary.getFile().getPresentableUrl();
      final List<String> classes = findClasses(presentableUrl);
      component.setClasses(classes);
    }
  }

  private void populateVulnerableComponents(final List<VulnerableComponent> vulnerableComponents) {
    components.clear();
    vulnerableComponents.forEach(component -> components.put(component.getPackageUrl().toString(), component));
  }
}
