package com.doddi.vulnerability_scanner_idea_plugin.listener.maven;

import java.util.Set;
import java.util.stream.Collectors;

import org.sonatype.goodies.packageurl.PackageUrl;

import com.doddi.vulnerability_scanner_idea_plugin.module.LibraryToScan;
import com.doddi.vulnerability_scanner_idea_plugin.service.VulnerabilityService;
import com.intellij.jarRepository.RepositoryLibrarySynchronizer;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.roots.OrderRootType;
import com.intellij.openapi.roots.libraries.Library;
import com.intellij.openapi.vfs.VirtualFile;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.idea.maven.project.MavenProjectsManager.Listener;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class MavenProjectListener implements Listener
{
  private final static Logger LOGGER = LoggerFactory.getLogger(MavenProjectListener.class);

  private final Project project;

  public MavenProjectListener(final Project project) {
    this.project = project;
    VulnerabilityService.getInstance().setPopulator(new MavenPopulator());
  }

  @Override
  public void activated() {
    LOGGER.info("Maven project {} activated", project.getName());
    checkForUpdate();
  }

  @Override
  public void projectImportCompleted() {
    LOGGER.info("Maven project {} imported", project.getName());
    checkForUpdate();
  }

  public void checkForUpdate() {
    final VulnerabilityService vulnerabilityService = VulnerabilityService.getInstance();
    final Set<LibraryToScan> libraries = getLibraries();
    vulnerabilityService.checkLibraries(libraries);
  }

  Set<LibraryToScan> getLibraries() {
    final Set<LibraryToScan> libraries = RepositoryLibrarySynchronizer.collectLibraries(project, library -> true)
        .stream()
        .map(this::collectLibrariesToScan)
        .collect(Collectors.toSet());
    return libraries;
  }

  @NotNull
  private LibraryToScan collectLibrariesToScan(final Library library) {
    return new LibraryToScan(getPackageUrl(library.getName()), getClassFile(library));
  }

  @NotNull
  private VirtualFile getClassFile(final Library library) {
    final VirtualFile[] files = library.getFiles(OrderRootType.CLASSES);
    if (files.length > 0 && files[0].exists()) {
      return files[0];
    }
    return null;
  }

  private PackageUrl getPackageUrl(final String library) {
    final String[] split = library.toLowerCase().split(":");
    return PackageUrl.builder().type(split[0].trim())
        .namespace(split[1].trim())
        .name(split[2].trim())
        .version(split[3].trim())
        .build();
  }
}
