package com.doddi.vulnerability_scanner_idea_plugin.util.nexusiqclient;

import java.io.IOException;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

import org.sonatype.goodies.packageurl.PackageUrl;

import com.doddi.vulnerability_scanner_idea_plugin.util.nexusiqclient.application.Application;
import com.doddi.vulnerability_scanner_idea_plugin.util.nexusiqclient.application.ApplicationSummaries;
import com.doddi.vulnerability_scanner_idea_plugin.util.nexusiqclient.application.ApplicationSummary;
import com.doddi.vulnerability_scanner_idea_plugin.util.nexusiqclient.application.Applications;
import com.doddi.vulnerability_scanner_idea_plugin.util.nexusiqclient.component.ComponentDetailsRequest;
import com.doddi.vulnerability_scanner_idea_plugin.util.nexusiqclient.component.ComponentDetailsRequest.PackageUrlAsString;
import com.doddi.vulnerability_scanner_idea_plugin.util.nexusiqclient.component.ComponentDetailsResponse;
import com.doddi.vulnerability_scanner_idea_plugin.util.nexusiqclient.evaluation.ApplicationEvaluationRequest;
import com.doddi.vulnerability_scanner_idea_plugin.util.nexusiqclient.evaluation.ApplicationEvaluationResponse;
import com.doddi.vulnerability_scanner_idea_plugin.util.nexusiqclient.evaluation.EvaluationResults;
import com.doddi.vulnerability_scanner_idea_plugin.util.nexusiqclient.evaluation.repository.RepositoryComponent;
import com.doddi.vulnerability_scanner_idea_plugin.util.nexusiqclient.evaluation.repository.RepositoryEvaluationRequest;
import com.doddi.vulnerability_scanner_idea_plugin.util.nexusiqclient.evaluation.repository.RepositoryEvaluationResponse;
import com.doddi.vulnerability_scanner_idea_plugin.util.nexusiqclient.remediation.RemediationRequest;
import com.doddi.vulnerability_scanner_idea_plugin.util.nexusiqclient.remediation.RemediationResponse;
import com.google.gson.Gson;
import com.intellij.openapi.diagnostic.Logger;
import okhttp3.Authenticator;
import okhttp3.Credentials;
import okhttp3.HttpUrl;
import okhttp3.MediaType;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Request.Builder;
import okhttp3.RequestBody;
import okhttp3.Response;
import org.jetbrains.annotations.NotNull;


public class NexusIQClient
{
  public static final Logger LOGGER = Logger.getInstance(NexusIQClient.class);

  //Todo /version - should work for both cloud and IQ
  private static final String ENDPOINT_ASSETS = "/assets/index.html";

  private static final String ENDPOINT_APPLICATIONS = "/rest/integration/applications";

  public static final String ENDPOINT_APPLICATION = "/api/v2/applications";

  public static final String ENDPOINT_APPLICATION_EVALUATION = "/api/v2/evaluation/applications/";

  public static final String ENDPOINT_APPLICATION_EVALUATION_RESULTS = "/api/v2/evaluation/applications/";

  public static final String ENDPOINT_REMEDIATION_REQUEST = "/api/v2/components/remediation/application/";

  public static final String ENDPOINT_COMPONENT_DETAILS = "/api/v2/components/details";

  public static final String ENDPOINT_REPOSITORY_EVALUATION_ADHOC = "/rest/integration/repositories/%s/%s/evaluate/adhoc";

  private final String url;

  private final String username;

  private final String password;

  private final Gson gson = new Gson();

  private static final MediaType JSON = MediaType.parse("application/json; charset=utf-8");

  public NexusIQClient(final String url) {
    this(url, "", "");
  }

  public NexusIQClient(final String url, final String username, final String password) {
    this.url = url;
    this.username = username;
    this.password = password;
  }

  private OkHttpClient getAuthenticatedHttpClient() {
    final Authenticator authenticator = getAuthenticator();
    return new OkHttpClient.Builder()
        .authenticator(authenticator).build();
  }

  private Authenticator getAuthenticator() {
    return (route, response) -> {
      final String credentials = Credentials.basic(NexusIQClient.this.username, NexusIQClient.this.password);
      return response.request().newBuilder().header("Authorization", credentials).build();
    };
  }

  public boolean checkAssetsUrl() {
    final OkHttpClient client = new OkHttpClient();

    final Request request = new Builder()
        .url(url + ENDPOINT_ASSETS)
        .build();

    final Response response;
    try {
      response = client.newCall(request).execute();
    }
    catch (IOException | IllegalArgumentException e) {
      LOGGER.warn("Unable to connect");
      return false;
    }
    return response.isSuccessful();
  }

  public List<String> fetchApplicationIds() {
    final OkHttpClient client = getAuthenticatedHttpClient();

    final HttpUrl.Builder builder = HttpUrl.parse(this.url + ENDPOINT_APPLICATIONS)
        .newBuilder()
        .addQueryParameter("goal", "EVALUATE_COMPONENT");

    final Request request = new Builder()
        .url(builder.build())
        .build();

    try {
      final Response response = client.newCall(request).execute();
      if (response.isSuccessful()) {

        final ApplicationSummaries applicationSummaries = gson
            .fromJson(response.body().string(), ApplicationSummaries.class);

        return Arrays.stream(applicationSummaries.getApplicationSummaries())
            .map(ApplicationSummary::getPublicId)
            .collect(Collectors.toList());
      }
    }
    catch (IOException e) {
      LOGGER.warn("Unable to get list of application ids");
    }

    return null;
  }

  public String getInternalAppId(final String applicationId) {
    final OkHttpClient client = getAuthenticatedHttpClient();

    final HttpUrl.Builder builder = HttpUrl.parse(this.url + ENDPOINT_APPLICATION)
        .newBuilder()
        .addQueryParameter("publicId", applicationId);

    final Request request = new Builder()
        .url(builder.build())
        .build();

    try {
      final Response response = client.newCall(request).execute();
      if (response.isSuccessful()) {

        final Applications applications = gson
            .fromJson(response.body().string(), Applications.class);

        return Arrays.stream(applications.getApplications())
            .map(Application::getId)
            .findFirst()
            .orElse(null);
      }
    }
    catch (IOException e) {
      LOGGER.warn("Unable to get list of application ids");
    }
    return null;
  }

  public ApplicationEvaluationResponse evaluateComponentsAgainstApplication(final String internalId,
                                                                            final List<PackageUrl> componentsToScan)
  {

    final Component[] components = componentsToScan.stream()
        .map(PackageUrl::toString)
        .map(Component::new)
        .toArray(Component[]::new);

    final ApplicationEvaluationRequest submitRequest = new ApplicationEvaluationRequest();
    submitRequest.setComponents(components);

    final OkHttpClient client = getAuthenticatedHttpClient();

    final HttpUrl.Builder builder = HttpUrl.parse(this.url + ENDPOINT_APPLICATION_EVALUATION + internalId)
        .newBuilder();

    final Request request = new Builder()
        .url(builder.build())
        .post(RequestBody.create(gson.toJson(submitRequest), JSON))
        .build();

    try {
      final Response response = client.newCall(request).execute();
      if (response.isSuccessful()) {
        return gson.fromJson(response.body().string(), ApplicationEvaluationResponse.class);
      }
    }
    catch (IOException e) {
      LOGGER.warn("Unable to submit components");
    }

    return null;
  }

  public EvaluationResults fetchApplicationEvaluationResults(final String internalId, final String resultId) {
    final OkHttpClient client = getAuthenticatedHttpClient();

    final HttpUrl.Builder builder = HttpUrl
        .parse(this.url + ENDPOINT_APPLICATION_EVALUATION_RESULTS + internalId + "/results/" + resultId)
        .newBuilder();

    final Request request = new Builder()
        .url(builder.build())
        .build();

    try {
      int attempts = 0;
      while (attempts++ <= 10) {
        final Response response = client.newCall(request).execute();
        if (response.isSuccessful()) {
          return gson.fromJson(response.body().string(), EvaluationResults.class);
        }
        else {
          try {
            Thread.sleep(1000);
          }
          catch (InterruptedException e) {
            LOGGER.warn("Unable to wait");
          }
        }
      }
    }
    catch (IOException e) {
      LOGGER.warn("Unable to get list of application ids");
    }
    return null;
  }

  public RemediationResponse fetchComponentRemediation(final String internalId, final PackageUrl purl) {

    final RemediationRequest remediationRequest = new RemediationRequest(purl.toString());

    final OkHttpClient client = getAuthenticatedHttpClient();

    final HttpUrl.Builder builder = HttpUrl.parse(this.url + ENDPOINT_REMEDIATION_REQUEST + internalId)
        .newBuilder();

    final Request request = new Builder()
        .url(builder.build())
        .post(RequestBody.create(gson.toJson(remediationRequest), JSON))
        .build();

    try {
      final Response response = client.newCall(request).execute();
      if (response.isSuccessful()) {
        return gson.fromJson(response.body().string(), RemediationResponse.class);
      }
    }
    catch (IOException e) {
      LOGGER.warn("Unable to submit components");
    }

    return null;
  }

  public ComponentDetailsResponse fetchComponentDetails(final List<PackageUrl> componentsToScan) {
    final OkHttpClient client = getAuthenticatedHttpClient();

    final ComponentDetailsRequest componentDetailsRequest = new ComponentDetailsRequest();
    final List<PackageUrlAsString> packageUrlAsStrings = componentsToScan.stream()
        .map(component -> new PackageUrlAsString(component.toString()))
        .collect(Collectors.toList());
    componentDetailsRequest.setComponents(packageUrlAsStrings);

    final HttpUrl.Builder builder = HttpUrl
        .parse(this.url + ENDPOINT_COMPONENT_DETAILS)
        .newBuilder();

    final Request request = new Builder()
        .url(builder.build())
        .post(RequestBody.create(gson.toJson(componentDetailsRequest), JSON))
        .build();

    try {
      final Response response = client.newCall(request).execute();
      if (response.isSuccessful()) {
        return gson.fromJson(response.body().string(), ComponentDetailsResponse.class);
      }
    }
    catch (IOException ioException) {
      LOGGER.warn("Unable to get component details");
    }

    return null;
  }

  public RepositoryEvaluationResponse evaluateComponentsAgainstRepository(final String repository,
                                                                          final @NotNull String projectName,
                                                                          final List<Component> componentsToScan)
  {
    final OkHttpClient client = getAuthenticatedHttpClient();

    final RepositoryEvaluationRequest repositoryEvaluationRequest = new RepositoryEvaluationRequest();
    repositoryEvaluationRequest.setCause("adhoc");
    final List<RepositoryComponent> components = componentsToScan.stream()
        .map(component -> {
          final RepositoryComponent repositoryComponent = new RepositoryComponent();
          repositoryComponent.setFormat(PackageUrl.parse(component.getPackageUrl()).getType());
          repositoryComponent.setHash(component.getHash());
          repositoryComponent.setPathname(component.getPackageUrl());
          return repositoryComponent;
        })
        .collect(Collectors.toList());
    repositoryEvaluationRequest.setComponents(components);

    final HttpUrl.Builder builder = HttpUrl
        .parse(this.url + String.format(ENDPOINT_REPOSITORY_EVALUATION_ADHOC, repository, projectName))
        .newBuilder();

    final Request request = new Builder()
        .url(builder.build())
        .post(RequestBody.create(gson.toJson(repositoryEvaluationRequest), JSON))
        .build();

    try {
      final Response response = client.newCall(request).execute();
      if (response.isSuccessful()) {
        return gson.fromJson(response.body().string(), RepositoryEvaluationResponse.class);
      }
    }
    catch (IOException ioException) {
      LOGGER.warn("Unable to evaluate against a repository");
    }

    return null;
  }
}
