package com.doddi.vulnerability_scanner_idea_plugin.service.vulnerability;

import java.util.List;
import java.util.Set;

import org.sonatype.goodies.packageurl.PackageUrl;

import com.doddi.vulnerability_scanner_idea_plugin.entity.VulnerableComponent;
import com.doddi.vulnerability_scanner_idea_plugin.service.VulnerabilityCacheService;
import com.doddi.vulnerability_scanner_idea_plugin.service.vulnerability.VulnerabilityCacheServiceImpl.CachedScanResult;
import org.jetbrains.annotations.NotNull;
import org.junit.Before;
import org.junit.Test;

import static java.util.Arrays.asList;
import static java.util.stream.Collectors.toList;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.core.IsCollectionContaining.hasItems;
import static org.hamcrest.core.IsEqual.equalTo;
import static org.hamcrest.core.IsNull.nullValue;

public class VulnerabilityCacheServiceImplTest
{
  private static final String PURL = "pkg:maven/commons-cli/commons-cli@1.3.1?type=jar";

  private static final String PURL2 = "pkg:maven/commons-cli/commons-cli@1.3.2?type=jar";

  private VulnerabilityCacheService underTest;

  @Before
  public void setUp() throws Exception {
    this.underTest = new VulnerabilityCacheServiceImpl();
  }

  @Test
  public void shouldCacheComponent() throws Exception {
    VulnerableComponent component = buildTestComponent(PURL);

    underTest.cache(component);

    assertThat(underTest.get(component.getPackageUrl()).getVulnerableComponent(), equalTo(component));
  }

  @Test
  public void shouldCacheMultipleComponents() throws Exception {
    VulnerableComponent component1 = buildTestComponent(PURL);
    VulnerableComponent component2 = buildTestComponent(PURL2);

    underTest.cache(asList(component1, component2));

    List<PackageUrl> purls = asList(component1.getPackageUrl(), component2.getPackageUrl());

    Set<CachedScanResult> cachedComponents = underTest.get(purls).getCachedComponents();
    
    List<VulnerableComponent> vulnerableComponents = cachedComponents.stream()
        .map(CachedScanResult::getVulnerableComponent)
        .collect(toList());
    assertThat(vulnerableComponents, hasItems(component1, component2));
  }

  @Test
  public void shouldExpireCache() throws Exception {
    VulnerableComponent component = buildTestComponent(PURL);

    underTest.setCacheExpiration(1);

    underTest.cache(component);

    Thread.sleep(1L);

    assertThat(underTest.get(component.getPackageUrl()), nullValue());
  }

  @Test
  public void shouldLimitCacheSize() throws Exception {
    VulnerableComponent component1 = buildTestComponent(PURL);
    VulnerableComponent component2 = buildTestComponent(PURL2);

    underTest.setMaxCacheSize(1);

    underTest.cache(component1);
    underTest.cache(component2);

    assertThat(underTest.get(component1.getPackageUrl()), nullValue());
    assertThat(underTest.get(component2.getPackageUrl()).getVulnerableComponent(), equalTo(component2));
  }

  @Test
  public void shouldReturnCachedComponents() throws Exception {
    VulnerableComponent component1 = buildTestComponent(PURL);
    VulnerableComponent component2 = buildTestComponent(PURL2);

    underTest.cache(component1);
    underTest.cache(component2);

    List<PackageUrl> purls = asList(component1.getPackageUrl(), component2.getPackageUrl());

    Set<CachedScanResult> cachedComponents = underTest.get(purls).getCachedComponents();

    List<VulnerableComponent> vulnerableComponents = cachedComponents.stream()
        .map(CachedScanResult::getVulnerableComponent)
        .collect(toList());
    
    assertThat(vulnerableComponents, hasItems(component1, component2));
  }

  @Test
  public void shouldReturnNonCachedComponents() throws Exception {
    VulnerableComponent component1 = buildTestComponent(PURL);
    PackageUrl notCachedUrl = buildTestComponent(PURL2).getPackageUrl();

    underTest.cache(component1);

    List<PackageUrl> purls = asList(component1.getPackageUrl(), notCachedUrl);

    Set<CachedScanResult> cachedComponents = underTest.get(purls).getCachedComponents();

    List<VulnerableComponent> vulnerableComponents = cachedComponents.stream()
        .map(CachedScanResult::getVulnerableComponent)
        .collect(toList());
    
    assertThat(vulnerableComponents, hasItems(component1));
    assertThat(underTest.get(purls).getNotFoundInCache(), hasItems(notCachedUrl));
  }

  @Test
  public void shouldCachePurlsWithoutVulns() throws Exception {
    List<PackageUrl> purls = asList(buildTestComponent(PURL).getPackageUrl(),
        buildTestComponent(PURL2).getPackageUrl());

    underTest.cacheNonVulnerableComponents(purls);

    for (PackageUrl purl : purls) {
      assertThat(underTest.get(purl).getVulnerableComponent(), nullValue());
    }
  }

  @NotNull
  private VulnerableComponent buildTestComponent(final String purl) {
    return new VulnerableComponent()
    {
      @Override
      public String buildPackageInformation(final String currentScannerName, final String currentScannerLink) {
        return null;
      }

      @Override
      public PackageUrl getPackageUrl() {
        return PackageUrl.parse(purl);
      }
    };
  }
}
